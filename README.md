## Завдання 1

### Щоб побачити відчутний виграш від кешу, у коді використано штучно вигідний сценарій:
- 45 000 раз викликається Range для одного і того самого відрізка (тому вже після першого обчислення наступні 44 999 отримають суму з кешу миттєво).
- 5 000 Update відбуваються далеко за межами цього відрізка, тож кешовані дані не інвалідовуються.

Час виконання без кешування: 3.33 секунд
Час виконання з LRU-кешем: 0.03 секунд

## Завдання 2

LRU-кеш у Python виявився ефективнішим для обчислення чисел Фібоначчі на великих n. 
Splay Tree теж повторно використовує проміжні значення, але вартість операцій переструктурування дерева (сплайювання) є більшою 
за накладні витрати вбудованого кешу Python.

![alt text](Снимок.PNG)
